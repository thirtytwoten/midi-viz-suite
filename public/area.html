<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script type="text/javascript" src="//d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="js/third-party/MidiConvert.js"></script>
<script type="text/javascript" src="js/third-party/Tone.js"></script>
<link rel="stylesheet" type="text/css" href="css/style.css">
<style>
button {
/*  width: 100px;
  left: 50%;
  margin-top: 20px;
  margin-left: -50px;
  height: 40px;
  text-align: center;
  position: absolute;*/
  pointer-events: none;
  opacity: 0.4;
}
button.active {
  pointer-events: initial;
  opacity: 1;
}
</style>
</head>
<body>
<button>play song</button>
<svg width="1200" height="1000"></svg>
<script>
let synth;
// lazy globals for browser runtime hackery
let midiData, noteData, stackedData, dataNest, measureCount, measurePeriod;
const NOTES = ["A", "As", "B", "C", "Cs", "D", "Ds", "E", "F", "Fs", "G", "Gs"];
const BEAT_RESOLUTION = 1;

function getNoteLetter(note) {
  return note.name.slice(0,-1).replace('#','s');
}

MidiConvert.load("bwv-846.midi").then(function(midi){
  midiData = midi;
  let bpMeasure = midiData.timeSignature[0];
  let bpMinute = midiData.header.bpm;
  let beatPeriod = (bpMinute / 60);
  measurePeriod = bpMeasure * beatPeriod;
  let measureResolution = bpMeasure * BEAT_RESOLUTION;
  let facetLength = measurePeriod / measureResolution;
  let duration = midiData.duration;
  measureCount = Math.ceil(duration / (bpMeasure * beatPeriod));

  //let notes = midiData.tracks[2].notes;
  let notes = midiData.tracks.reduce(function(notes, track){
    if(!track.isPercussion){
      notes = notes.concat(track.notes);
    }
    return notes;
  },[]);
  noteData = notes.map(function(n){ return Object.assign(n, {
      letter: getNoteLetter(n),
      measure: Math.floor(n.time / measurePeriod),
      measureFacet: Math.floor((n.time % measurePeriod) / facetLength)
  }); });

  stackedData = stackNotesByMeasure(noteData)
  plotGraph(stackedData, measureCount);

  prepAudio(midi);
});

function stackNotesByMeasure(noteData) {
  nestByMeasureFacet = d3.nest().key(function(n){ return n.measureFacet });
  nestByMeasure = d3.nest().key(function(n){ return n.measure });
  nestByFacet = d3.nest().key(function(n){ return n.measure * n.measureFacet });

  let nest = nestByMeasure;


  function rollupNoteFreq(d){ return d.reduce(function(noteCounts,note){
    noteCounts[note.letter] = noteCounts[note.letter] || 0;
    noteCounts[note.letter]++;
    return noteCounts;
  },{})}

  function rollupNoteMagnitude(d){ return d.reduce(function(noteMagnitude,note){
    noteMagnitude[note.letter] = noteMagnitude[note.letter] || 0;
    noteMagnitude[note.letter] += note.velocity * Math.min(note.duration, measurePeriod);
    // includes each note that is started in facet, better implementation would break up the parts of notes into correct facets
    return noteMagnitude;
  },{})}

  let rollup = rollupNoteMagnitude;

  function sortAscKey(a,b){return parseInt(a.key) - parseInt(b.key)}

  function flattenFacet(facet){
    return Object.assign(facet.value, { facetIndex: parseInt(facet.key) });
  }

  dataNest = nest.rollup(rollup).entries(noteData)
                  .sort(sortAscKey).map(flattenFacet);

  let stack = d3.stack()
    .keys(NOTES).value(function(d,key){ return d[key] || 0 })
    .offset(d3.stackOffsetNone);

  return stack(dataNest);
}

function plotGraph(stackedData, facetCount) {
  var svg = d3.select("svg");
  var areaGraph = svg.append("g")
        .attr("transform", "translate(" + 100 + "," + 1000 + ")");

  var x = d3.scaleLinear().range([0, 1000]);
  var y = d3.scaleLinear().range([60, 0]);
  x.domain([0,facetCount - 1]);

  var areaByMeasure = d3.area()
      //.curve(d3.curveBasis)
      .x(function(d, i) { return x(d.data.facetIndex) })
      .y0(function(d, i) { return y(d[0]) })
      .y1(function(d, i) { return y(d[1]) });

  areaGraph.selectAll(".layer")
    .data(stackedData)
    .enter().append("g")
    .attr("class", "layer")
    .append("path")
    .attr("class", function(d){return "area" + " n" + d.key})
    .attr("d", areaByMeasure);
}

////// song play back

var button = document.querySelector("button");
  button.addEventListener("click", function(){
    if (Tone.Transport.state === "started"){
      Tone.Transport.stop();
      button.textContent = "START";
    } else {
      Tone.Transport.start("+0.1", 0);
      button.textContent = "STOP";
    }
  });

function prepAudio(midi){
  Tone.Transport.bpm.value = midi.bpm;
  Tone.Transport.timeSignature = midi.timeSignature;

  synth = new Tone.PolySynth(8, Tone.Synth, {
    "oscillator": {
      "type": "sine3"
    },
    "envelope": {
      "attack": 0.03,
      "decay": 0.1,
      "sustain": 0.2,
      "release": 0.6
    }
  }).toMaster();

  let rightHand = midi.get("Piano right").notes;
  let leftHand = midi.get("Piano left").notes;
  let rightHandPart = new Tone.Part(playNote, rightHand).start(0);
  let leftHandPart = new Tone.Part(playNote, leftHand).start(0);

  button.classList.add("active")
}

function playNote(time, event){
  synth.triggerAttackRelease(event.name, event.duration, time, event.velocity);
  //svg.select(`#key${event.midi}`).transition().attr('fill', 'blue');
  //setTimeout(function(){svg.select(`#key${event.midi}`).transition().attr('fill', 'none')}, event.duration * 1000);
  //console.log(event);
}

</script>
</body>
</html>