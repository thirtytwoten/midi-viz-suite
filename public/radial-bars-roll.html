<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script type="text/javascript" src="//d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="js/third-party/MidiConvert.js"></script>
<script type="text/javascript" src="js/third-party/Tone.js"></script>
<link rel="stylesheet" type="text/css" href="css/style.css">
<style>
  .songBox {
    width: 1000px;
  }
  #freqChart {
    width: 500px;
    float: left;
  }
  #radChart {
    width: 500px;
    float: left;
  }
  #scrollChart {
    width: 1000px;
    float: left;
  }
</style>
</head>
<body>
<div class="songBox">
  <h3 class="songName"></h3>
  <div id="freqChart"></div>
  <div id="radChart"></div>
  <div id="scrollChart"></div>
  <button>play</button>
</div>

<script>
let freqChart;
let scrollChartSvg, scaleScrollX, selectedRange;
let midiData, noteData, stackedData; // lazy globals for browser runtime coding
const NOTES = ["A", "As", "B", "C", "Cs", "D", "Ds", "E", "F", "Fs", "G", "Gs"];
const BEAT_RESOLUTION = 16;

function getNoteLetter(note) {
  return note.name.slice(0,-1).replace('#','s');
}

function getNoteId(note) {
  return `${note.name}-${note.time}`.replace('#','s').replace('.','-')
}

MidiConvert.load("bwv-846.midi").then(function(midi){
  midiData = midi;
  let bpMeasure = midiData.header.timeSignature[0];
  let bpMinute = midiData.header.bpm;
  let beatPeriod = (bpMinute / 60);
  let measurePeriod = bpMeasure * beatPeriod;
  let measureResolution = bpMeasure * BEAT_RESOLUTION;
  let facetLength = measurePeriod / measureResolution;

  let notes = midiData.tracks[1].notes.concat(midiData.tracks[2].notes);
  noteData = notes.map(function(n){ return Object.assign(n, {
      id: getNoteId(n),
      keyNumber: parseInt(n.midi),
      letter: getNoteLetter(n),
      time: n.time,
      measure: parseInt(n.time / measurePeriod),
      measureFacet: parseInt((n.time % measurePeriod) / facetLength)
  }); });

  stackedData = stackNotesByFacet(noteData);
  plotRadialChart(stackedData, measureResolution);
  freqChart = new FreqChart(noteData, "#freqChart");//plotFreqChart(noteData);
  freqChart.plot();
  plotScrollChart(noteData);
  prepAudio(midi);
  d3.select(".songBox .songName").text(midiData.header.name);
});

function stackNotesByFacet(noteData) {
  let nestByFacet = d3.nest().key(function(n){ return n.measureFacet });

  function rollupNoteFreq(d){ return d.reduce(function(noteCounts,facet){
    noteCounts[facet.letter] = noteCounts[facet.letter] || 0;
    noteCounts[facet.letter]++;
    return noteCounts;
  },{})}

  function sortAscKey(a,b){return parseInt(a.key) - parseInt(b.key)}

  function flattenFacet(facet){
    return Object.assign(facet.value, { facetIndex: parseInt(facet.key) });
  }

  let dataNest = nestByFacet.rollup(rollupNoteFreq).entries(noteData)
                  .sort(sortAscKey).map(flattenFacet);

  let stack = d3.stack()
    .keys(NOTES).value(function(d,key){ return d[key] || 0 })
    .offset(d3.stackOffsetNone);

  return stack(dataNest);
}

function plotScrollChart(noteData){
  function minSecFmt(seconds){
    let min = parseInt(seconds / 60);
    let sec = parseInt(seconds % 60);
    return (min + ":" + (sec < 10 ? '0' : '') + sec);
  }

  var margin = {top: 20, right: 20, bottom: 30, left: 40},
      width = 1000 - margin.left - margin.right,
      height = 300 - margin.top - margin.bottom;

  scaleScrollX = d3.scaleLinear().range([0, width]);
  let scaleScrollY = d3.scaleLinear().range([height, 0]);

  var xAxis = d3.axisBottom(scaleScrollX).tickFormat(minSecFmt),
      yAxis = d3.axisLeft(scaleScrollY);

  var brush = d3.brushX()
    .extent([[0, 0], [width, height]])
    .on("end", brushed);

  scrollChartSvg = d3.select("#scrollChart").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom);

  scrollChartSvg.append("defs").append("clipPath")
      .attr("id", "clip")
    .append("rect")
      .attr("width", width)
      .attr("height", height);

  var context = scrollChartSvg.append("g")
    .attr("class", "context");

  scaleScrollX.domain(d3.extent(noteData, function(d) { return d.time; }));
  scaleScrollY.domain([d3.min(noteData, function(d) { return d.keyNumber; })-2, 
            d3.max(noteData, function(d) { return d.keyNumber; })+2 ]);

  var dots = context.append("g");
    dots.attr("clip-path", "url(#clip)");
    dots.selectAll(".dots")
        .data(noteData)
        .enter().append("rect")
        .attr('class', function(n) { return 'dot' + ' n' + n.letter })
        .attr('id', function(n){return n.id})
        .style("opacity", .5)
        .attr("x", function(n) { return scaleScrollX(n.time) })
        .attr("y", function(n) { return scaleScrollY(n.keyNumber) })
        .attr("width", function(n) { return scaleScrollX(n.noteOff) - scaleScrollX(n.noteOn) })
        .attr("height", 4);
            
    context.append("g")
          .attr("class", "axis axis--x")
          .attr("transform", "translate(0," + height + ")")
          .call(scaleScrollX);

    context.append("g")
          .attr("class", "brush")
          .call(brush)
          .call(brush.move, scaleScrollX.range());

    context.append("line")
        .attr("id", "playHead")
        .attr("x1", scaleScrollX(0))
        .attr("y1", height + 10)
        .attr("x2", scaleScrollX(0))
        .attr("y2", -10)
        .style("opacity", .3)
        .style("stroke", "black");

  function brushed() {
    var selection = d3.event.selection;
    //scaleScrollX.domain(selection.map(scaleScrollX.invert, scaleScrollX));
    selectedRange = selection.map(scaleScrollX.invert, scaleScrollX)
    freqChart.subSelection(selectedRange);
    // ^ gives [selectionStartTime, selectionEndTime]
    //plotFreqChart(notesInTimeRange(noteData, selectedRange))

  }
}

// function notesInTimeRange(notes,range) {
//   return notes.filter(function(n){
//     return n.time >= range[0] && n.time <= range[1];
//   });
// }

function FreqChart(noteData, selector) {
  this.rawData = noteData;
  this.graphData = this.formatData(noteData);
  this.selector = selector;
  this.margin = {top: 20, right: 20, bottom: 30, left: 40};
  this.width = 500 - this.margin.left - this.margin.right;
  this.height = 300 - this.margin.top - this.margin.bottom;
  this.xScale = d3.scaleBand().range([0, this.width]).padding(0.1);
  this.yScale = d3.scaleLinear().range([this.height, 0]);
  this.svg = this.makeSvg();
  this.bars = null;
}

FreqChart.prototype = {
  formatData: function(noteData) {
    return d3.nest().key(function(n){ return n.letter })
      .rollup(function(notes){ return notes.length })
      .entries(noteData);
  },
  subSelection: function(timeRange){
    let filteredRaw = this.rawData.filter(function(n){
      return n.time >= timeRange[0] && n.time <= timeRange[1];
    });
    this.graphData = this.formatData(filteredRaw);
    this.redraw();
  },
  makeSvg: function(){
    return d3.select(this.selector).append('svg')
              .attr("width", this.width + this.margin.left + this.margin.right)
              .attr("height", this.height + this.margin.top + this.margin.bottom)
              .append("g").attr("transform","translate(" + this.margin.left + "," + this.margin.top + ")");
  },
  plot: function() {
    let fc = this;
    this.xScale.domain(NOTES);
    this.yScale.domain([0, d3.max(this.graphData, function(d) { return d.value; })]);

    this.bars = this.svg.selectAll(".bar")
      .data(this.graphData);

    this.draw();
    this.svg.append("g")
        .attr("transform", "translate(0," + fc.height + ")")
        .call(d3.axisBottom(fc.xScale));
    this.svg.append("g")
        .call(d3.axisLeft(fc.yScale));
  },
  draw: function() {
    let fc = this;
    this.bars.enter().append("rect")
      .attr('class', function(d) { return 'bar' + ' n' + d.key; })
      .attr("x", function(d) { return fc.xScale(d.key); })
      .attr("width", fc.xScale.bandwidth())
      .attr("y", function(d) { return fc.yScale(d.value); })
      .attr("height", function(d) { return fc.height - fc.yScale(d.value); });
  },
  redraw: function() {
    //d3.select(this.selector).remove();
    this.bars.remove();
    this.svg.selectAll('g').remove();
    //this.bars.exit().remove();
    //this.draw();
    this.plot();
  }
};

function plotRadialChart(stackedData, facetCount) {
  var margin = {top: 20, right: 20, bottom: 30, left: 40},
      width = 400 - margin.left - margin.right,
      height = 400 - margin.top - margin.bottom;

  var radChartSvg = d3.select("#radChart").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g").attr("transform","translate(" + (margin.left + width/2) + "," + (margin.top + height/2) + ")");

  var ang = d3.scaleLinear().range([0 , 2 * Math.PI]);
  var rad = d3.scaleLinear().range([15,30]);
  ang.domain([0,facetCount - 1]);

  var radialAreaByMeasure = d3.radialArea()
      .curve(d3.curveBasisClosed)
      .angle(function(d, i) { return ang(d.data.facetIndex) })
      .innerRadius(function(d, i) { return rad(d[0]) })
      .outerRadius(function(d, i) { return rad(d[1]) });

  radChartSvg.selectAll(".layer")
    .data(stackedData)
    .enter().append("g")
    .attr("class", "layer")
    .append("path")
    .attr("class", function(d){return "area" + " n" + d.key})
    .attr("d", radialAreaByMeasure);
}

/// audio playback
var button = document.querySelector("button");
button.addEventListener("click", function(){
  if (Tone.Transport.state === "started"){
    Tone.Transport.stop();
    button.textContent = "play";
  } else {
    Tone.Transport.start("+0.1", 0);
    button.textContent = "STOP";
  }
});

function prepAudio(midi, noteData){
  Tone.Transport.bpm.value = midi.bpm;
  Tone.Transport.timeSignature = midi.timeSignature;

  synth = new Tone.PolySynth(8, Tone.Synth, {
    "oscillator": {
      "type": "sine3"
    },
    "envelope": {
      "attack": 0.03,
      "decay": 0.1,
      "sustain": 0.2,
      "release": 0.6
    }
  }).toMaster();

  let tones = midi.get("Piano right").notes.concat(midi.get("Piano left").notes);
  let noteDataPart = new Tone.Part(playNote, tones).start(0);

  button.classList.add("active");
}

function playNote(time, event){
  synth.triggerAttackRelease(event.name, event.duration, time, event.velocity);
  d3.select('#playHead')
      .attr("x1", scaleScrollX(event.time))
      .attr("x2", scaleScrollX(event.time))
  scrollChartSvg.select(`#${event.id}`)
    .style('opacity',1).attr('height',6)
    .transition().duration(event.duration * 1000)
    .style('opacity',0.5).attr('height',4);
}

</script>
</body>
</html>